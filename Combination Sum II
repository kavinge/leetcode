/*
Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

Each number in C may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
Elements in a combination (a1, a2, � , ak) must be in non-descending order. (ie, a1 ? a2 ? � ? ak).
The solution set must not contain duplicate combinations.
For example, given candidate set 10,1,2,7,6,1,5 and target 8, 
A solution set is: 
[1, 7] 
[1, 2, 5] 
[2, 6] 
[1, 1, 6] 
*/

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<vector<int> > result;
void sumHelper(vector<int> &candidates,int target,int index,int* select){
    if(index<0){
        return;
    }
    for(int i=index;i>=0;i--){
        if(i==index||candidates[i]!=candidates[i+1]){
            int temp=candidates[i];
            if(temp>target){
                continue;
            }
            select[i]=1;
            if(temp==target){
                vector<int> ans;
                for(int j=0;j<candidates.size();j++){
                    if(select[j]){
                        ans.push_back(candidates[j]);
                    }
                }
                result.push_back(ans);
            }else{
                sumHelper(candidates,target-temp,i-1,select);
            }
            select[i]=0;
        }
    }
}

vector<vector<int> > combinationSum2(vector<int> &candidates, int target) {
    result.clear();

    if(candidates.size()==0||target<=0){
        return result;
    }
    sort(candidates.begin(),candidates.end());
    int* select=new int[candidates.size()]();
    sumHelper(candidates,target,candidates.size()-1,select);
    return result;

}
