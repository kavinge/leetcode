/*
Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

For example:
Given binary tree {3,9,20,#,#,15,7},

    3
   / \
  9  20
    /  \
   15   7
return its bottom-up level order traversal as:

[
  [15,7]
  [9,20],
  [3],
]
*/

#include <iostream>
#include <vector>
using namespace std;
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

vector<vector<int> > levelOrderBottom(TreeNode *root)
{
    vector<vector<int> > result;
    if(root==NULL)
    {
        return result;
    }
    vector<vector<TreeNode*> > que;
    int level=0;
    vector<TreeNode*> temp;
    temp.push_back(root);
    que.push_back(temp);
    while(que.size()>level)
    {
        vector<TreeNode*> parent=que[level];
        vector<TreeNode*> childs;
        for(int i=0; i<parent.size(); i++)
        {
            if(parent[i]->left!=NULL)
            {
                childs.push_back(parent[i]->left);
            }
            if(parent[i]->right!=NULL)
            {
                childs.push_back(parent[i]->right);
            }
        }
        if(childs.size()>0)
        {
            que.push_back(childs);

        }
        level++;
    }

    for(int i=que.size()-1; i>=0; i--)
    {
        vector<TreeNode*> tn=que[i];
        vector<int> in;
        for(int j=0; j<tn.size(); j++)
        {
            in.push_back(tn[j]->val);
        }
        result.push_back(in);
    }

    return result;

}

